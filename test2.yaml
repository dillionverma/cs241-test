test0:
  in: |-
    wain(int a, int b) {
      return a / b;
    }
  out: |
    WAIN wain
    LPAREN (
    INT int
    ID a
    COMMA ,
    INT int
    ID b
    RPAREN )
    LBRACE {
    RETURN return
    ID a
    SLASH /
    ID b
    SEMI ;
    RBRACE }
test1:
  in: |
    //// Gordon V. Cormack
    //silly
    //
    //
    //

    int wain(int a,int b){
       int x = 0;   // x will hold the lower value
       int y = 0;   // y will hold the higher value
       int c = 0;   // c will be the accumulator
       int divisor = 0;
       int done = 0;
       if (a < b) {   // test if a less than b
          x = a;      // assign x the lesser
          y = b;      // assign y the greater
       } else {       // I guess a isn't less than b
          x = b;      // assign x the lesser
          y = c;      // assign y the greater
       }
       if (x ! = 1) {
          x = x + 1;
       }else{}
       if (x == 2) {
          if (y >= 2) {
             c = 1;
          }else{}
          x = x + 1;
       }else{}
       if (x%2 == 0) {
          x = x + 1;
  error: true
test2:
  in: |-
    wain(int a, int b) {
       int xxx ;
       int yyy;
       if (x == y) { a = b; } else { c = d; }
       while (a+b <= c*d) {}
       a = b+1*(c%d-e/x);
       c = 132;
       return a + b;   // unhelpful comment about summing a and b
    }

    int wain(int * a, int N){
       int i = 0;
       int j = 0;
       int k = 0;
       int sum = 0;
       int n = 0;
       int max = 0;
       n = *(a);
       //for (i=0;i<n;i++) {
       while (i < n) { 
          //for (j=0;j<n;j++) {
          j = 0;
          while (j < n) {
             sum = 0;
             //for (k=0;k<n;k++) {
             k = 0;
             while (k < n) {
                //sum = sum + A[i,k] + B[k,j];
                sum = sum + *(a+1+n*i+k) * *(a+1+n*n+n*k+j);
                k = k + 1;
  out: |
    WAIN wain
    LPAREN (
    INT int
    ID a
    COMMA ,
    INT int
    ID b
    RPAREN )
    LBRACE {
    INT int
    ID xxx
    SEMI ;
    INT int
    ID yyy
    SEMI ;
    IF if
    LPAREN (
    ID x
    EQ ==
    ID y
    RPAREN )
    LBRACE {
    ID a
    BECOMES =
    ID b
    SEMI ;
    RBRACE }
    ELSE else
    LBRACE {
    ID c
    BECOMES =
    ID d
    SEMI ;
    RBRACE }
    WHILE while
    LPAREN (
    ID a
    PLUS +
    ID b
    LE <=
    ID c
    STAR *
    ID d
    RPAREN )
    LBRACE {
    RBRACE }
    ID a
    BECOMES =
    ID b
    PLUS +
    NUM 1
    STAR *
    LPAREN (
    ID c
    PCT %
    ID d
    MINUS -
    ID e
    SLASH /
    ID x
    RPAREN )
    SEMI ;
    ID c
    BECOMES =
    NUM 132
    SEMI ;
    RETURN return
    ID a
    PLUS +
    ID b
    SEMI ;
    RBRACE }
    INT int
    WAIN wain
    LPAREN (
    INT int
    STAR *
    ID a
    COMMA ,
    INT int
    ID N
    RPAREN )
    LBRACE {
    INT int
    ID i
    BECOMES =
    NUM 0
    SEMI ;
    INT int
    ID j
    BECOMES =
    NUM 0
    SEMI ;
    INT int
    ID k
    BECOMES =
    NUM 0
    SEMI ;
    INT int
    ID sum
    BECOMES =
    NUM 0
    SEMI ;
    INT int
    ID n
    BECOMES =
    NUM 0
    SEMI ;
    INT int
    ID max
    BECOMES =
    NUM 0
    SEMI ;
    ID n
    BECOMES =
    STAR *
    LPAREN (
    ID a
    RPAREN )
    SEMI ;
    WHILE while
    LPAREN (
    ID i
    LT <
    ID n
    RPAREN )
    LBRACE {
    ID j
    BECOMES =
    NUM 0
    SEMI ;
    WHILE while
    LPAREN (
    ID j
    LT <
    ID n
    RPAREN )
    LBRACE {
    ID sum
    BECOMES =
    NUM 0
    SEMI ;
    ID k
    BECOMES =
    NUM 0
    SEMI ;
    WHILE while
    LPAREN (
    ID k
    LT <
    ID n
    RPAREN )
    LBRACE {
    ID sum
    BECOMES =
    ID sum
    PLUS +
    STAR *
    LPAREN (
    ID a
    PLUS +
    NUM 1
    PLUS +
    ID n
    STAR *
    ID i
    PLUS +
    ID k
    RPAREN )
    STAR *
    STAR *
    LPAREN (
    ID a
    PLUS +
    NUM 1
    PLUS +
    ID n
    STAR *
    ID n
    PLUS +
    ID n
    STAR *
    ID k
    PLUS +
    ID j
    RPAREN )
    SEMI ;
    ID k
    BECOMES =
    ID k
    PLUS +
    NUM 1
    SEMI ;
test3:
  in: |-

    wain(int a, int b) {
       while (a > b) {a = a - 1;}
       return a;   // unhelpful comment about summing a and b
    }

    int wain(int* array, int size) {
        int* copy = NULL;
        int i = 0;
        int j = 0;
        int t = 0;
        int k = 0;
        int sum = 0;

        // make a copy
        copy = new int[size];
        i = 0;
        while(i < size) {
            sum = sum + *(array+i);
            *(copy+i) = *(array+i);
            i = i + 1;
        }

        // bubble sort
        k = 0;
        while(k < size) {
            i = 0;
            while(i < size-1) {
                j = i + 1;
                if( *(array+i) > *(array+j) ) {
                    t = *(array+i);
  out: |
    WAIN wain
    LPAREN (
    INT int
    ID a
    COMMA ,
    INT int
    ID b
    RPAREN )
    LBRACE {
    WHILE while
    LPAREN (
    ID a
    GT >
    ID b
    RPAREN )
    LBRACE {
    ID a
    BECOMES =
    ID a
    MINUS -
    NUM 1
    SEMI ;
    RBRACE }
    RETURN return
    ID a
    SEMI ;
    RBRACE }
    INT int
    WAIN wain
    LPAREN (
    INT int
    STAR *
    ID array
    COMMA ,
    INT int
    ID size
    RPAREN )
    LBRACE {
    INT int
    STAR *
    ID copy
    BECOMES =
    NULL NULL
    SEMI ;
    INT int
    ID i
    BECOMES =
    NUM 0
    SEMI ;
    INT int
    ID j
    BECOMES =
    NUM 0
    SEMI ;
    INT int
    ID t
    BECOMES =
    NUM 0
    SEMI ;
    INT int
    ID k
    BECOMES =
    NUM 0
    SEMI ;
    INT int
    ID sum
    BECOMES =
    NUM 0
    SEMI ;
    ID copy
    BECOMES =
    NEW new
    INT int
    LBRACK [
    ID size
    RBRACK ]
    SEMI ;
    ID i
    BECOMES =
    NUM 0
    SEMI ;
    WHILE while
    LPAREN (
    ID i
    LT <
    ID size
    RPAREN )
    LBRACE {
    ID sum
    BECOMES =
    ID sum
    PLUS +
    STAR *
    LPAREN (
    ID array
    PLUS +
    ID i
    RPAREN )
    SEMI ;
    STAR *
    LPAREN (
    ID copy
    PLUS +
    ID i
    RPAREN )
    BECOMES =
    STAR *
    LPAREN (
    ID array
    PLUS +
    ID i
    RPAREN )
    SEMI ;
    ID i
    BECOMES =
    ID i
    PLUS +
    NUM 1
    SEMI ;
    RBRACE }
    ID k
    BECOMES =
    NUM 0
    SEMI ;
    WHILE while
    LPAREN (
    ID k
    LT <
    ID size
    RPAREN )
    LBRACE {
    ID i
    BECOMES =
    NUM 0
    SEMI ;
    WHILE while
    LPAREN (
    ID i
    LT <
    ID size
    MINUS -
    NUM 1
    RPAREN )
    LBRACE {
    ID j
    BECOMES =
    ID i
    PLUS +
    NUM 1
    SEMI ;
    IF if
    LPAREN (
    STAR *
    LPAREN (
    ID array
    PLUS +
    ID i
    RPAREN )
    GT >
    STAR *
    LPAREN (
    ID array
    PLUS +
    ID j
    RPAREN )
    RPAREN )
    LBRACE {
    ID t
    BECOMES =
    STAR *
    LPAREN (
    ID array
    PLUS +
    ID i
    RPAREN )
    SEMI ;
test4:
  in: |-
    int wain(int a, int b){
       int foo = 16;
       int bar = 1073741825;
       println(foo);
       println(bar);
       return foo+bar;
    }
  out: |
    INT int
    WAIN wain
    LPAREN (
    INT int
    ID a
    COMMA ,
    INT int
    ID b
    RPAREN )
    LBRACE {
    INT int
    ID foo
    BECOMES =
    NUM 16
    SEMI ;
    INT int
    ID bar
    BECOMES =
    NUM 1073741825
    SEMI ;
    PRINTLN println
    LPAREN (
    ID foo
    RPAREN )
    SEMI ;
    PRINTLN println
    LPAREN (
    ID bar
    RPAREN )
    SEMI ;
    RETURN return
    ID foo
    PLUS +
    ID bar
    SEMI ;
    RBRACE }
test5:
  in: |-
  out: |
test6:
  in: |-
  out: |
test7:
  in: |-
  out: |
test8:
  in: |-
  out: |
test9:
  in: |-
  out: |
test10:
  in: |-
  error: true
test11:
  in: |-
  error: true
test12:
  in: |-
  error: true
test13:
  in: |-
  out: |
test14:
  in: |-
  out: |
test15:
  in: |-
  out: |
test16:
  in: |-
  out: |
test17:
  in: |-
  out: |
test18:
  in: |-
  out: |
